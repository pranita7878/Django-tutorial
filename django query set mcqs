Sr No	Question	Options	Answer
1	What does objects.all() do in a Django model?	Retrieves all objects, sorted by ID., Returns an empty queryset., Fetches all objects, preserving the model's default ordering. , Queries objects based on specific criteria.	Fetches all objects, preserving the model's default ordering.	
2	What's the difference between filter() and exclude() methods?	Both exclude objects; filter() has additional ordering capabilities., Both include objects; filter() provides stricter filters. , filter() includes objects meeting criteria, exclude() removes them., filter() and exclude() are synonymous.	filter() includes objects meeting criteria, exclude() removes them.	
3	How does values() affect queryset results?	Returns the entire object instance with specified fields. , Creates a dictionary-like representation of objects with specified fields., Orders the queryset by the chosen fields., Doesn't impact results; used for database optimization.	Creates a dictionary-like representation of objects with specified fields.	
4	What does annotate() do?	Renames existing fields in the result. , Calculates aggregates (e.g., count, maximum) without retrieving full objects. , Filters objects based on complex logical expressions., Performs aggregations and filtering simultaneously.	Calculates aggregates (e.g., count, maximum) without retrieving full objects.	
5	When might you use defer() or only()?	To order queryset results in a specific way., To optimize performance by selecting or deferring specific fields. , To create aggregations or perform calculations on fields. , To create relationships between models using foreign keys.	To optimize performance by selecting or deferring specific fields.	
6	What happens when you chain queryset methods (e.g., filter() . annotate() . order_by())?	Methods are executed in a random order. , Leftmost method has highest precedence, then rightmost. , Methods are applied from left to right in the chain. , Only the last method used in the chain has any effect.	Methods are applied from left to right in the chain.	
7	What is the purpose of prefetch_related()?	Joins related models eagerly within the same query. , Lazily fetches related data on demand when accessed. , Defines relationships between models using foreign keys. , Orders queryset results based on related model fields.	Joins related models eagerly within the same query.	
8	How can you create complex filtering criteria using Q objects?	Define logical expressions like AND, OR, and NOT. , Only filter on exact field values., Sort queryset results based on combined conditions, Create custom aggregations for calculations.	Define logical expressions like AND, OR, and NOT.	
9	What is the benefit of using iterators with querysets?	Iterators improve query performance, even for large datasets. , They're required for all queryset operations. , They automatically load all objects into memory., They offer no advantage over loading the entire queryset at once.	Iterators improve query performance, even for large datasets.	
10	Explain the trade-offs between using raw SQL versus Django's ORM (Object-Relational Mapper).	Raw SQL always offers better performance; ORM is simpler to use. , ORM is always slower; raw SQL gives more control., ORM provides security and portability, but complex queries might require raw SQL., Raw SQL is essential for all database interactions; ORM is rarely used.	ORM provides security and portability, but complex queries might require raw SQL.	
